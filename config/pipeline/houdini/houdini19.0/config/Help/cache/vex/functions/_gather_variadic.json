{"type": "root", "attrs": {"type": "include"}, "body": [{"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Ray sending options"], "extent": [16, 42], "body": [{"type": "arg_group", "body": [{"ext": null, "type": "arg", "indent": 0, "text": ["width"], "role": "item", "extent": [42, 56], "body": [{"type": "para", "indent": 4, "text": ["Specifies the filter width at the source of the ray. If ", {"type": "code", "text": ["angle"]}, " is also specified, the filter width will become larger with increasing distance along the ray. By default, the filter width will be initialized from the current shading context, so it\u2019s normally not necessary to specify ", {"type": "code", "text": ["width"]}, " directly. Negative values are ignored and will also cause the filter width to be initialized from the current shading context."], "extent": [95, 519]}], "container": true, "attrs": {"type": "float", "default": "-1"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["distribution"], "role": "item", "extent": [519, 539], "body": [{"type": "para", "indent": 4, "text": ["Determines the sampling distribution."], "extent": [585, 628]}, {"type": "para", "indent": 4, "text": ["For ", {"scheme": "Vex", "value": "/vex/functions/gather", "type": "link", "text": "", "fallback_text": "gather()", "fullpath": "/vex/functions/gather"}, ":"], "extent": [628, 650]}, {"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["cosine"]}, " \u2013 Rays are distributed by the cosine (diffuse) function over the hemisphere."], "extent": [650, 743]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["uniform"]}, " \u2013 Rays are distributed uniformly over the hemisphere"], "extent": [743, 814]}], "container": true}, {"type": "para", "indent": 4, "text": ["For ", {"scheme": "Vex", "value": "/vex/functions/sample_geometry", "type": "link", "text": "", "fallback_text": "sample_geometry()", "fullpath": "/vex/functions/sample_geometry"}, ":"], "extent": [814, 845]}, {"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["area"]}, " \u2013 Samples are distributed by primitive area"], "extent": [845, 903]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["parametric"]}, " \u2013 Samples are distributed by primitive ID, subdivision ID, and parametric surface coordinates (s, t)."], "extent": [903, 1025]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["solidangle"]}, " \u2013 Samples are distributed either by primitive area or by primitive area and solid angle subtended by the primitive."], "extent": [1025, 1162]}], "container": true}], "container": true, "attrs": {"type": "string", "default": "\"cosine\""}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["biasdir"], "role": "item", "extent": [1162, 1177], "body": [{"type": "para", "indent": 4, "text": ["Overrides the bias direction when ", {"type": "ui", "text": ["Bias Along Normal"]}, " is enabled.  When no ", {"type": "code", "text": ["biasdir"]}, " is specified, the geometric normal ", {"type": "code", "text": ["Ng"]}, " is used.  When bias along normal is disabled, this option has no effect."], "extent": [1213, 1418]}], "container": true, "attrs": {"type": "vector", "default": "Ng"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["SID"], "role": "item", "extent": [1418, 1429], "body": [{"type": "para", "indent": 4, "text": ["Sample identifier to be passed to the called shader.  If the calling shader has used SID to generate samples, it can be useful to pass the modified sample identifier to the called shader so that it can begin sampling at the specified offset.  This value will be used to initialize the SID global in the hit surface."], "extent": [1465, 1786]}], "container": true, "attrs": {"type": "int", "default": "0"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["rayweight"], "role": "item", "extent": [1786, 1803], "body": [{"type": "para", "indent": 4, "text": ["A hint to mantra to indicate the relative contribution of this ray to the final shading. This value is used by the ray clip threshold to limit sending of rays (similar to ray bounce)."], "extent": [1841, 2030]}], "container": true, "attrs": {"type": "float", "default": "1"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["raystyle"], "role": "item", "extent": [2030, 2046], "body": [{"type": "para", "indent": 4, "text": ["The type of rays you are sending.  Mantra will use ", {"type": "code", "text": ["raystyle"]}, " to determine both the default raytracing mask and bounce limit used for ray termination."], "extent": [2093, 2249]}, {"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["reflect"]}, " \u2013 Sending reflection rays.  Mantra will use the reflection mask and reflection limit to terminate raytracing."], "extent": [2249, 2376]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["refract"]}, " \u2013 (default) Sending refraction rays.  Mantra will use the refraction mask and refraction limit to terminate raytracing."], "extent": [2376, 2513]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["diffuse"]}, " \u2013 Sending diffuse rays.  Mantra will use the diffuse limit for diffuse rays."], "extent": [2513, 2607]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["shadow"]}, " \u2013 Sending shadow rays.  Mantra will not modify the raytracing level and will trace against ", {"type": "code", "text": ["shadowmask"]}, " if inside a shadow or light shader."], "extent": [2607, 2763]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["primary"]}, " \u2013 Sending primary rays.  This style can be used when a shader needs to change the direction of a primary ray without affecting the behavior of render settings that apply only to directly visible objects (such as matte and phantom).  Mantra will still increment the raytracing level when sending ", {"type": "code", "text": ["primary"]}, " rays."], "extent": [2763, 3091]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["nolimit"]}, " \u2013 Sending reflection rays with no limit on the number of raytracing bounces.  Mantra will still increment the raytracing level when sending ", {"type": "code", "text": ["nolimit"]}, " rays."], "extent": [3091, 3265]}], "container": true}], "container": true, "attrs": {"type": "string", "default": "\"refract\""}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["categories"], "role": "item", "extent": [3265, 3283], "body": [{"type": "para", "indent": 4, "text": ["A category expression used to select the objects which can be hit by rays. When specified, this overrides the existing ", {"type": "code", "text": ["reflectcategories"]}, " and ", {"type": "code", "text": ["refractcategories"]}, " parameters."], "extent": [3306, 3490]}, {"type": "para", "indent": 4, "text": ["For example, ", {"type": "code", "text": ["^hidden"]}, " will hit all objects which do not have the hidden category, and ", {"type": "code", "text": ["shiny|happy"]}, " will hit all objects with either the shiny or happy category."], "extent": [3490, 3658]}, {"type": "para", "indent": 4, "text": ["The intersection of the scope and categories parameters are used to choose the objects which can be hit by rays."], "extent": [3658, 3776]}], "container": true, "attrs": {"type": "string"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["samplebase"], "role": "item", "extent": [3776, 3794], "body": [{"type": "para", "indent": 4, "text": ["Typically, rays are distributed over the surface of the micro-polygon being shaded. This argument can be used to control the area. A value of 0 will force all rays to be sent from the same point. A value of 1 will cover the entire micro-polygon. (Gather only)"], "extent": [3832, 4097]}], "container": true, "attrs": {"type": "float", "default": "0"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["transparentsamples"], "role": "item", "extent": [4097, 4123], "body": [{"type": "para", "indent": 4, "text": ["The number of transparent samples to take for stochastic transparency with array outputs. Normally this value should be set to 1 unless you have requested exports in array variables - in which case the ray tracer will insert an entry in the array for each sample along the ray."], "extent": [4159, 4442]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [4442, 4452], "body": [{"type": "para", "indent": 8, "text": [{"type": "code", "text": ["transparentsamples"]}, " must be 1 when importing ", {"type": "code", "text": ["F"]}, " or ", {"type": "code", "text": ["ray:material"]}, " using ", {"type": "code", "text": ["screendoor"]}, " ", {"type": "code", "text": ["samplefilter"]}, "."], "extent": [4452, 4565]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"type": "int", "default": "1"}, "variadic": true}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Sending information to the surface\u2019s shader"], "extent": [4565, 4615], "body": [{"type": "para", "indent": 0, "text": ["Using a keyword in the form ", {"type": "code", "text": ["\"send:", {"type": "var", "text": ["name"]}, "\", value"]}, ", you can pass data from the originating surface to surfaces which are intersected by the ray. These arguments pass any values you want."], "extent": [4615, 4810]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\ngather(P, dir, \"send:N\", normalize(N)) { ... }\n"], "extent": [4810, 4871]}, {"type": "para", "indent": 0, "text": ["You can extract this passed data on the receiving end (that is, in the surface being hit by the ray) with the ", {"scheme": "Vex", "value": "/vex/functions/rayimport", "type": "link", "text": "", "fallback_text": "rayimport()", "fullpath": "/vex/functions/rayimport"}, " function. The first argument is the name (without the ", {"type": "code", "text": ["send:"]}, " prefix) and the second argument is a variable in which to store the imported value."], "extent": [4871, 5145]}, {"type": "para", "indent": 0, "text": [{"type": "code", "text": ["int rayimport(string name, <type> &value)"]}], "extent": [5145, 5190]}, {"type": "para", "indent": 0, "text": [{"type": "code", "text": ["rayimport"]}, " returns ", {"type": "code", "text": ["1"]}, " if the value was imported successfully."], "extent": [5190, 5256]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Importing information from the ray"], "extent": [5256, 5297], "body": [{"type": "para", "indent": 0, "text": ["You can specify names of global or exported variables to import from the hit shader in the form ", {"type": "code", "text": ["\"", {"type": "var", "text": ["varname"]}, "\", &var"]}, ", typically including ", {"type": "code", "text": ["Cf"]}, " (color vector of surface hit) and ", {"type": "code", "text": ["Of"]}, " (opacity vector of surface hit)."], "extent": [5297, 5515]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\nvector  hitcf;\ngather(P, dir, \"bias\", 0.01, \"Cf\", hitcf) {...}\n"], "extent": [5515, 5592]}, {"type": "para", "indent": 0, "text": ["In addition, you can import the following special keywords to get information about the ray itself:"], "extent": [5592, 5694]}, {"type": "arg_group", "body": [{"ext": null, "type": "arg", "indent": 0, "text": ["ray:origin"], "role": "item", "extent": [5694, 5712], "body": [{"type": "para", "indent": 4, "text": ["The origin of the ray (defined in ", {"type": "code", "text": ["else"]}, " clause also)."], "extent": [5736, 5796]}], "container": true, "attrs": {"type": "&vector"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["ray:direction"], "role": "item", "extent": [5796, 5817], "body": [{"type": "para", "indent": 4, "text": ["The direction of the ray (defined in ", {"type": "code", "text": ["else"]}, " clause also)."], "extent": [5841, 5904]}], "container": true, "attrs": {"type": "&vector"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["ray:length"], "role": "item", "extent": [5904, 5922], "body": [{"type": "para", "indent": 4, "text": ["The distance to the first surface which was hit by the ray."], "extent": [5945, 6010]}], "container": true, "attrs": {"type": "&float"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["ray:area"], "role": "item", "extent": [6010, 6026], "body": [{"type": "para", "indent": 4, "text": ["The total surface area of all the geometry in the raytracing scope."], "extent": [6049, 6122]}], "container": true, "attrs": {"type": "&float"}, "variadic": true}, {"ext": null, "type": "arg", "indent": 0, "text": ["ray:solidangle"], "role": "item", "extent": [6122, 6144], "body": [{"type": "para", "indent": 4, "text": ["The estimated solid angle subtended by all geometry in the raytracing scope.  For large objects close to or enclosing the ray origin, this may be a very poor estimate while for individual primitives the estimate can be very good."], "extent": [6167, 6402]}], "container": true, "attrs": {"type": "&float"}, "variadic": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 0, "text": ["You can retrieve information about more than one hit along\nthe ray by requesting data in an array variable.  When an imported\nvalue is of an array type, the ", {"scheme": "Vex", "value": "/vex/functions/trace", "type": "link", "text": "", "fallback_text": "trace()", "fullpath": "/vex/functions/trace"}, " function will automatically append\nan entry in the array for each individual hit point that was composited\nduring ray tracing.  For the ", {"type": "code", "text": ["opacity"]}, " sample filter (see below), an entry will be\ncreated in the array for each semi-transparent sample encountered until\nfull opacity is reached.  When using array outputs, it may also be useful\nto use the ", {"type": "code", "text": ["all"]}, " sample filter, which will cause all hits along the ray to\nbe inserted regardless of whether the opacity limit was exceeded."], "extent": [6402, 7049]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n// Find the position and normal for all hit points along the ray,\n// regardless of visibility.\nvector a_pos[];\nvector a_nml[];\ntrace(P, dir, Time,\n        \"samplefilter\", \"all\",\n            \"P\", a_pos,\n            \"N\", a_nml);\n"], "extent": [7049, 7290]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Sample filtering options"], "extent": [7290, 7323], "body": [{"type": "para", "indent": 0, "text": ["By default, Houdini composites the global variables using opacity blending. In some cases, it\u2019s more useful to get the value from the closest surface (regardless of whether it\u2019s transparent). You can use the special ", {"type": "code", "text": ["samplefilter"]}, " keyword with a string value of either ", {"type": "code", "text": ["closest"]}, " or ", {"type": "code", "text": ["opacity"]}, " to control whether the value of a global is from the closest surface or opacity blended."], "extent": [7323, 7706]}, {"type": "arg_group", "body": [{"ext": null, "type": "arg", "indent": 0, "text": ["samplefilter"], "role": "item", "extent": [7706, 7726], "body": [{"type": "para", "indent": 4, "text": ["When the ", {"type": "code", "text": ["samplefilter"]}, " keyword is encountered in the argument list, ", {"type": "em", "text": ["all following"]}, " import variables will use the specified filtering mode. You can specify multiple ", {"type": "code", "text": ["samplefilter"]}, " arguments in a single gather statement to filter different variables in different ways."], "extent": [7749, 8023]}, {"type": "para", "indent": 4, "text": ["The current types of allowed for ", {"type": "code", "text": ["samplefilter"]}, " are"], "extent": [8023, 8080]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["minimum"]}], "extent": [8080, 8095], "body": [{"type": "para", "indent": 12, "text": ["Take the minimum value of all the samples.  Note that with tuple values, the minimum value of each component will be used."], "extent": [8095, 8230]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["maximum"]}], "extent": [8230, 8245], "body": [{"type": "para", "indent": 12, "text": ["Take the maximum value of all the samples.  Note that with tuple values, the maximum value of each component will be used."], "extent": [8245, 8380]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["opacity"]}], "extent": [8380, 8395], "body": [{"type": "para", "indent": 12, "text": ["Composite samples using the over operation."], "extent": [8395, 8451]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["closest"]}], "extent": [8451, 8466], "body": [{"type": "para", "indent": 12, "text": ["This is the default behavior, returning only the closest surface."], "extent": [8466, 8544]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["screendoor"]}], "extent": [8544, 8562], "body": [{"type": "para", "indent": 12, "text": ["Use stochastic compositing of the samples."], "extent": [8562, 8617]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["sum"]}], "extent": [8617, 8628], "body": [{"type": "para", "indent": 12, "text": ["Return the sum of the values for all samples."], "extent": [8628, 8686]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["sum_square"]}], "extent": [8686, 8704], "body": [{"type": "para", "indent": 12, "text": ["Return the sum of the squares of the values of all samples."], "extent": [8704, 8776]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["sum_reciprocal"]}], "extent": [8776, 8798], "body": [{"type": "para", "indent": 12, "text": ["Return the sum of the reciprocals of each sample."], "extent": [8798, 8861]}], "container": true}], "container": true}], "container": true, "attrs": {"type": "string"}, "variadic": true}], "container": true, "role": "item_group"}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [8861, 8867], "body": [{"type": "para", "indent": 4, "text": ["When using ", {"scheme": "Vex", "value": "/vex/functions/sample_geometry", "type": "link", "text": "", "fallback_text": "sample_geometry()", "fullpath": "/vex/functions/sample_geometry"}, ", the default ", {"type": "code", "text": ["samplefilter"]}, " is set to ", {"type": "code", "text": ["closest"]}, " by default, since opacity blending only works when compositing data along a ray."], "extent": [8867, 9034]}], "container": true}], "container": true, "role": "item_group"}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\ngather(P, dir,\n        \"samplefilter\", \"opacity\",\n            \"Cf\", hitCf,\n            \"Of\", hitOf,\n        \"samplefilter\", \"closest\",\n            \"P\", hitP,\n            \"N\", hitN)\n{\n    trace(pos, dir, time,\n            // Composite the bsdf of the hit surfaces using stochastic transparency\n            \"samplefilter\", \"screendoor\",\n            \"F\", hitF,\n            // But find the closest sample's position\n            \"samplefilter\", \"closest\",\n            \"P\", hitP);\n}\n"], "extent": [9034, 9525]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Pipeline options"], "extent": [9525, 9551], "body": [{"type": "arg_group", "body": [{"ext": null, "type": "arg", "indent": 0, "text": ["pipeline"], "role": "item", "extent": [9551, 9568], "body": [{"type": "para", "indent": 4, "text": ["As you specify variables, you can intersperse ", {"type": "code", "text": ["pipeline"]}, " keyword options to control where in the pipeline to fill out read/write variables. The value can be one of ", {"type": "code", "text": ["surface"]}, ", ", {"type": "code", "text": ["atmosphere"]}, ", or ", {"type": "code", "text": ["displacement"]}, ". You can specify the ", {"type": "code", "text": ["pipeline"]}, " option multiple times. Each use of the option affects any variables specified after it (up to the next usage of ", {"type": "code", "text": ["pipeline"]}, " if any)."], "extent": [9591, 9967]}, {"lang": "vex", "type": "pre", "indent": 4, "text": ["\n    gather(p, d, \"pipeline\", \"surface\", \"Cf\", surfCf,\n                 \"pipeline\", \"atmosphere\" \"Cf\", fogCf, \"P\", hitP)\n    "], "extent": [9967, 10113]}], "container": true, "attrs": {"type": "string"}, "variadic": true}], "container": true, "role": "item_group"}]}]}